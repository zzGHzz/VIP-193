\documentclass{article}

\usepackage{arxiv}

\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{url}   % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{lipsum}

\usepackage{longtable}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{setspace}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{multirow}

\title{VIP-193: Committee-Based POA}
\author{
  Ziheng (Peter) Zhou \vspace{1ex}\\
  VeChain Foundation \\
  \texttt{peter.zhou@vechain.com}
  \And
  Zhijie Ren \vspace{1ex} \\
  VeChain Foundation \\
  \texttt{zhijie.ren@vechain.com}
}

\date{\vspace{-5ex}}

\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}\vspace{3pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}\vspace{3pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}\vspace{3pt}}m{#1}}

\usepackage{abstract}
\renewcommand{\abstractname}{}
\renewcommand{\absnamepos}{empty}

\begin{document}
\maketitle

% \begin{abstract}
% \begin{itemize}
%     \item VIP: 193
%     \item Title: Committee-Based POA
%     \item Author: Ziheng Zhou (peter.zhou@vechain.com) and Zhijie Ren (zhijie.ren@vechain.com)
%     \item Category: Core
%     \item Status: Draft
%     \item CreateAt: 2019-11-05
% \end{itemize}
% \end{abstract}

% keywords can be removed
% \keywords{First keyword \and Second keyword \and More}


\section{Overview}
The Proof-of-Authority consensus algorithm~\cite{VWP18}, or PoA in short, is efficient of using network bandwidth. It divides time into rounds with a fixed length and assumes that the majority of its (authorized) nodes perform consensus in the same round. In each round, nodes select a leader (the node responsible for generating a new block) based on the round number, block height and their local views of the active nodes. Therefore, the procedure can be considered instant, which allows more time for transmitting transaction (TX) data in each consensus round.

However, PoA cannot prevent a malicious leader from causing temporary inconsistency by producing multiple blocks. To improve the security of PoA, we propose to introduce a committee (a group of selected nodes) to endorse the new block generated in each consensus round. The verifiable random function~(VRF)~\cite{PapEtAl99} is used for committee selection in each round. With the committee mechanism, a malicious leader would have to collude with committee members to cause inconsistency. However, the property of VRF guarantees that the committee is selected randomly. Therefore, it makes it much more difficult for adversaries to launch such attacks.

It is assumed that the network is synchronous and the messages are transmitted through gossip communication, i.e., if an honest node sends a message or an honest node receives a message, all other honest nodes will receive same message within at most a delay of $\tau$, which is determined by the network configuration and is known in advance.

%Note that besides the network synchrony, we also assume that messages be transmitted through gossip communication. Hence, if an honest node receives a message, all other honest nodes will receive the same message with a bounded delay. 
\section{Specifications}
\subsection{Notations}
\renewcommand{\arraystretch}{2}
\begin{longtable}{p{3cm} p{10cm}}
    Symbol  & Description \\
    \hline\hline
    $N$ & Total number of nodes \\
    \hline
    $u=1,2,\dots,N$ & node index \\
    \hline
    $H(\cdot)$ & Cryptographic hash function \\
    \hline
    ${\tt SIG}_u(\cdot)$ & Signature of $u$ \\
    \hline
    % $\left({\tt PK}_u,{\tt SK}_u\right)$ & Public and private keys generated by $u$ to sign blocks \\
    % \hline
    $\rho\left(\cdot\right)$ & Merkle root of the input set\\
    \hline
    $r$ & Consensus round number \\
    \hline
    $l_r=1,2,...,N$ & Leader in round $r$ \\
    \hline
    $\Sigma_r$ & Transaction set prepared by $l_r$ \\
    \hline
    $s_r$ & Block summary produced by $l_r$ \\
    \hline
    $x_r$ & Tx-set package produced by $l_r$ \\
    \hline
    $e_{u,r}$ & Endorsement produced by $u$ \\
    \hline
    $d$ & Number of endorsements required to produce a valid block \\
    \hline
    $\pi_{u,r}$ & VRF proof produced by $u$ \\
    \hline
    $h_r$ & Block header produced by $l_r$ \\
    \hline
    % $\tau_r$ & $s_r\,\|\,{\tt Sig}_{\,l_r}(s_r)$ \\
    % \hline
    % $\epsilon$ & Predefined threshold to determine committee membership \\
    % \hline
    % $B_{u,r}^*$ & Last block of the canonical chain (trunk) recognized by $u$ in round $r$\\ 
    % \hline
    % $H_{vrf},\Pi_{vrf},V_{vrf}$ & Functions that compute hash, generate proof and verify proof defined in the VRF scheme, respectively \\
    % \hline
    % $\left({\tt PK}_u^{vrf},{\tt SK}_u^{vrf}\right)$ & Public and private key pair generated by $u$ for VRF  \\
    % \hline
    % ${\tt M}_{\,r}$ & Common VRF message generated for committee selection \\
    % \hline
    % % $\omega$, $\omega^*$ & Branch and trunk \\
    % % \hline
    % $m$, $L$ & Epoch number and the number of consensus rounds in one epoch \\
    % \hline
    % $b_m$ & Random beacon computed using randomness from the last block of the $m$'th epoch \\
    % \hline
\end{longtable}

\subsection{Producing a New Block}

Algorithm~\ref{alg:block-gen} describes the procedure for leader~$l_r$ to publish a new block in round~$r$. During the process, nodes needs to deal with four types of packages: 
\begin{itemize}
    \item Block summary~$s_r$
    \item Tx-set package~$x_r$
    \item Endorsement~$e_{u,r}$
    \item Block header~$h_r$
\end{itemize}
They will be described in detail in later sections.

\begin{algorithm}[H]
\caption{Procedure for $l_r$ to publish a new block.}
\label{alg:block-gen}
\begin{spacing}{1.2}
\begin{algorithmic}[1]
    \vspace{1ex}
    \State Prepare and broadcast $s_r$
    \State Prepare and broadcast $x_r$ if there is any tx included in the new block
    \State Wait for $d$ valid endorsements 
    %and arrange the committee members such that ${\tt PK}_{u_1}^{vrf}<{\tt PK}_{u_2}^{vrf}<\dots<{\tt PK}_{u_d}^{vrf}$
    % \State $\Gamma_r\leftarrow{\tt SIG}_{u_1}(\tau_r)\,\|\,{\tt SIG}_{u_2}(\tau_r)\,\|\,\dots\,\|\,{\tt SIG}_{u_d}(\tau_r)$
    % \State Broadcast $\left(s_r,{\tt Sig}_{\,l_r}(s_r),{\tt Sig}_{\,l_r}(\Gamma_r),
    % \left\{{\tt SIG}_{u_i}(\tau_r),\pi_{u_i,r}\right\}_{i=1}^d\right)$
    % \State Construct header body~$\Omega$ and broadcast ${\tt Sig}_{\,l_r}(\Omega)$
    \State Prepare and broadcast $h_r$
\end{algorithmic}
\end{spacing}
\end{algorithm}

\subsection{Block Summary}
At the beginning of round~$r$, leader $l_r$ computes a summary of the proposed new block, $s_r$, and broadcast it for the committee members to endorse. A block summary must include the following information:
\begin{itemize}
    \item Parent header reference
    \item Merkle root of the transactions included in the new block, $\rho(\Sigma_r)$
    \item Round number, $r$
    \item Leader's signature, ${\tt SIG}_{\,l_r}(\bar{s}_r)$ where $\bar{s}_r$ represents the block summary without a signature
\end{itemize}

% Algorithms~\ref{alg:bs-gen} and \ref{alg:bs-valid} shows the computation and validation processes of $s_r$, respectively. 

% \begin{algorithm}[H]
% \caption{Procedure for $l_r$ to compute and broadcast $s_r$.}
% \label{alg:bs-gen}
% \begin{spacing}{1.2}
% \begin{algorithmic}[1]
%     \vspace{1ex}
%     \State Prepares $\Sigma_r$ and computes $\rho\left(\Sigma_r\right)$
%     \State Get $B_{l_r}^*$
%     % \State Get the last block on the canonical chain, $B_{l_r}^*$ and computer $h_0=H({\tt HEADER}(B_{l_r,r}^*))$
%     % \State $s_r\leftarrow h_0\,\|\,r\,\|\,\rho\left(\Sigma_r\right)$
%     \State Prepare $s_r$
%     \State Broadcast $\left(s_r,{\tt Sig}_{\,l_r}(s_r)\right)$
% \end{algorithmic}
% \end{spacing}
% \end{algorithm}

Algorithm~\ref{alg:bs-valid} shows how to validate an incoming block summary.

\begin{algorithm}[H]
\caption{Procedure for $u$ to validate $s_r$.}
\label{alg:bs-valid}
\begin{spacing}{1.2}
\begin{algorithmic}[1]
    \vspace{1ex}
    \State Verify ${\tt Sig}_{\,l_r}(\bar{s}_r)$
    \State Verify that $r$ is the current round
    \State Verify that $l_r$ is the round leader
    \State Verify that the parent block referred by $s_r$ is consistent with the latest block on the canonical chain
\end{algorithmic}
\end{spacing}
\end{algorithm}

\subsection{Tx-Set Package}
After broadcasting $s_r$, leader~$l_r$ needs to prepare and broadcast the tx-set package~$x_r$. A tx-set package must include the following information:
\begin{itemize}
    \item Round number, $r$
    \item Set of txs included in the new block, $\Sigma_r$
    \item Leader's signature, ${\tt SIG}_{\,l_r}(\bar{x}_r)$ where $\bar{x}_r$ represents the tx-set package without a signature
\end{itemize}

Algorithm~\ref{alg:txset-valid} shows how to validate an incoming tx-set package.

\begin{algorithm}[H]
\caption{Procedure for validating $x_r$.}
\label{alg:txset-valid}
\begin{spacing}{1.2}
\begin{algorithmic}[1]
    \vspace{1ex}
    \State Verify ${\tt SIG}_{\,l_r}(\bar{x}_r)$
    \State Verify that $r$ is the current round
    \State Verify that $l_r$ is the round leader
\end{algorithmic}
\end{spacing}
\end{algorithm}

\subsection{Endorsement}

After receiving and verifying $s_r$, nodes~$u$ that are selected as the committee members need to prepare and broadcast endorsements~$e_{u,r}$. An endorsement~$e_{u,r}$ must include the following information:
\begin{itemize}
    \item Received and verified block summary, $b_r$
    \item VRF proof of $u$'s committee membership, $\pi_{u,r}$
    \item Signature, ${\tt SIG}_{\,l_r}(\bar{e}_{u,r})$ where $\bar{e}_{u,r}$ represents the endorsement without a signature
\end{itemize}

{\color{red} Note that it is assumed that the private key used by $u$ to generate $\pi_{u,r}$ is different from the one that generates $u$'s address. It is also assumed that the corresponding public key that will be used by other nodes to verify VRF proof can be assessed so that it does not needs to be transmitted with $e_{u,r}$.}

% Here we define $\tau_r=s_r\,\|\,{\tt Sig}_{\,l_r}(s_r)$.
% \begin{algorithm}[H]
% \caption{Procedure for $u$ to endorse a new block.}
% \label{alg:endorse-gen}
% \begin{spacing}{1.2}
% \begin{algorithmic}[1]
%     \vspace{1ex}
%     \State Verify $s_r$ by Algorithm~\ref{alg:bs-valid}
%     \State Broadcast $\Big(u,s_r,{\tt SIG}_u(\tau_r),\pi_{u,r}\Big)$
% \end{algorithmic}
% \end{spacing}
% \end{algorithm}

Algorithm~\ref{alg:endorse-valid} shows how to validate an incoming endorsement by $u$.

\begin{algorithm}[H]
\caption{Procedure for validating $u$'s endorsement.}
\label{alg:endorse-valid}
\begin{spacing}{1.2}
\begin{algorithmic}[1]
    \vspace{1ex}
    \State Verify ${\tt SIG}_{u}(\tau_r)$
    \State Verify $s_r$ by Algorithm~\ref{alg:bs-valid}
    \State Verify $u$'s committee membership by Algorithm~\ref{alg:committee-valid}
\end{algorithmic}
\end{spacing}
\end{algorithm}

\subsection{Block Header}

After receiving $d$ valid endorsements, leader~$l_r$ needs to prepare and broadcast the header of the new block. A block header~$h_r$ must contain the following information:
\begin{itemize}
    \item Parent header reference 
    \item Round number, $r$
    \item Merkle tree root of the tx set, $\rho\left(\Sigma_r\right)$
    \item Leader's signature on the block summary, ${\tt Sig}_{\,l_r}(s_r)$
    \item VRF proofs of the committee membership from $d$ nodes, $\left\{\pi_{u_i,r}\right\}_{i=1}^d$
    \item Endorsement signatures from the same $d$ nodes, $\left\{{\tt SIG}_{u_i}(\bar{e}_{u,r})\right\}_{i=1}^d$
    \item $\forall\,1\leq i<j\leq N$, $\pi_{u_i,r}<\pi_{u,j}$. It is made to reduce the number of combinations $l_r$ can try when arranging the vrf proofs.
    \item Leader's signature, ${\tt Sig}_{\,l_r}(\bar{h}_r)$ where $\bar{h}_r$ represents the header without a signature
    % \item Committee member list $\left(u_1<u_2<\dots<u_d\right)$
    % \item Merkle tree root of VRF proofs $\left\{\pi_{u_i,r}\right\}_{i=1}^d$
    % \item Merkle tree root of signatures $\left\{{\tt SIG}_{u_i}(\tau_r)\right\}_{i=1}^d$
    % \item Signature ${\tt Sig}_{\,l_r}(\Gamma_r)$
    % \item Other necessary header elements such as the state root, receipt root, gas limit and etc.
\end{itemize}

% A block consists of a header $\left\{\Omega,{\tt Sig}_{\,l_r}(\Omega)\right\}$ and tx set~$\Sigma_r$. 
Algorithm~\ref{alg:header-valid} describes how to validate a block header generated in round $r$. 

%To prevent a malicious leader to deliberately delay the transmission of block elements to cause inconsistency, honest nodes would accept a new block only if they validated it in the same round.

\begin{algorithm}[H]
\caption{Procedure for validating the header of the new block generated in round $r$.}
\label{alg:header-valid}
\begin{spacing}{1.2}
\begin{algorithmic}[1]
    \vspace{1ex}
    \State Verify ${\tt Sig}_{\,l_r}(\bar{h}_r)$
    \State Verify that $r$ is the current round
    \State Verify that $l_r$ is the round leader
    \State Reconstruct and verify $s_r$ by Algorithm~\ref{alg:bs-valid}
    % \State Verify $\rho\left(\Sigma_r\right)$
    \For{$i=1,2,\dots,d$}
        \If{$i>1$}
            \State Verify that $\pi_{u,i-1} < \pi_{u,i}$
        \EndIf
        \State Reconstruct and Verify $e_{u_i,r}$ by Algorithm~\ref{alg:endorse-valid}
    \EndFor
    % \State Construct $\Gamma_r$ and verify ${\tt Sig}_{\,l_r}(\Gamma_r)$
    % \State Construct header body~$\Omega$ and verify ${\tt Sig}_{\,l_r}(\Omega)$
    % \State Verify $\Sigma_r$ 
\end{algorithmic}
\end{spacing}
\end{algorithm}

\subsection{Block Assembling}
To use the network bandwidth more efficient, the round leader does not broadcast the whole block, but broadcast the tx-set~$x_r$ and block header~$h_r$ asynchronously. Other nodes need to assemble the new block locally following Algorithm~\ref{alg:block-assembling}.

\begin{algorithm}[H]
\caption{Procedure for verify and assemble the new block generated in round $r$.}
\label{alg:block-assembling}
\begin{spacing}{1.2}
\begin{algorithmic}[1]
    \vspace{1ex}
    \State Verify $h_r$ by Algorithm~\ref{alg:header-valid}
    \State Verify $x_r$ by Algorithm~\ref{alg:txset-valid}
    \State Verify that $\rho(\Sigma_r)$ in $h_r$ is consistent with $x_r$
    \State Verify txs included in $x_r$
    \State Assemble the new block
\end{algorithmic}
\end{spacing}
\end{algorithm}

% \subsection{Canonical Chain Rule}
% In this subsection, we provide the rules for selecting the canonical chain (or the \textit{trunk}) based on the committee mechanism. Let $\omega$ be a branch, i.e., a chain of blocks. Given a block~$B$ on the branch, i.e.,~$B\in\omega$, we define the weight of the chain starting from $B$ till the end of $\omega$,~$W(\omega,B)$, as the size of the set that contains all the leaders and committee members who have their signatures included in at least one block on the chain. Note that a node is only counted once.

% Given two branches $\omega_1$ and $\omega_2$, let $B_0$ be the last block shared by $\omega_1$ and $\omega_2$, i.e., $B_0\in\omega_1\cap\,\omega_2$ and $\forall\, B'\in\omega_1\cap\,\omega_2,\, B'\preceq B_0$. Let $N(\omega,B)$ be the operator that finds the next block of $B$ on branch~$\omega$. We choose the canonical chain~$\omega^*$ from two branches~$\omega_1$ and $\omega_2$ by Algorithm~\ref{alg:canonical-chain} as shown below:

% \begin{algorithm}[H]
% \caption{Rules for choosing canonical chain~$\omega^*$ from branches~$\omega_1$ and $\omega_2$.}
% \label{alg:canonical-chain}
% \begin{spacing}{1.2}
% \begin{algorithmic}[1]
%     \vspace{1ex}
%     \State $B_1\leftarrow N(\omega_1,B_0)$
%     \State $B_2\leftarrow N(\omega_2,B_0)$
%     \vspace{1ex}
%     \While{$W(\omega_1,B_1)=W(\omega_2,B_2)$ \textbf{and} $N(\omega_1,B_1)\neq{\tt nil}$ \textbf{and} $N(\omega_2,B_2)\neq{\tt nil}$}
%         \State $B_1\leftarrow N(\omega_1,B_1)$
%         \State $B_2\leftarrow N(\omega_2,B_2)$
%     \EndWhile
%     \vspace{1ex}
%     \If{$W(\omega_1,B_1)>W(\omega_2,B_2)$}
%         \State $\omega^*\leftarrow\omega_1$
%     \ElsIf{$W(\omega_1,B_1)<W(\omega_2,B_2)$}
%         \State $\omega^*\leftarrow\omega_2$
%     \Else
%         \If{$B_1$ is published later than $B_2$}
%             \State $\omega^*\leftarrow\omega_1$
%         \Else
%             \State $\omega^*\leftarrow\omega_2$
%         \EndIf
%     \EndIf
% \end{algorithmic}
% \end{spacing}
% \end{algorithm}

\subsection{Committee Membership}
\label{sec:committee}
The verifiable random function can be considered a public-key version of keyed cryptographic hash. The hash of a given message can only be computed by the owner of the private key~${\tt SK}$ and can be verified by anyone given the public key~{\tt SK} and message~{\tt M}. The scheme defines the following functions:
\begin{itemize}
    \item $\pi\leftarrow\Pi_{vrf}({\tt SK},{\tt M})$ - function that generates VRF proof;
    \item $\{{\tt TRUE}, {\tt FALSE}\}\leftarrow V_{vrf}({\tt SK},{\tt M},\pi)$ - function that verify VRF proof;
    \item $h\leftarrow H_{vrf}({\tt SK},{\tt M})=H(\pi)$ - function that computes the hash.
\end{itemize}

Node~$u$ determines his committee membership using his private key~${\tt SK}_u$ by Algorithm~\ref{alg:committee-gen}. Here ${\tt M}_{\,r}$ can be locally computed by each node in a deterministic way and $\epsilon$ a predefined threshold. See Section~\ref{sec:beacon} for details of how to compute ${\tt M}_{\,r}$. Given the VRF proof~$\pi_{u,r}$ and the corresponding public key~${\tt PK}_u$, anyone can verify the membership claimed by $u$ by Algorithm~\ref{alg:committee-valid} below.

\begin{algorithm}[H]
\caption{Procedure for $u$ to determine his committee membership. }
\label{alg:committee-gen}
\begin{spacing}{1.2}
\begin{algorithmic}[1]
    \vspace{1ex}
    \State Compute ${\tt M}_{\,r}$
    \State Compute $\pi_{u,r} = \Pi_{vrf}({\tt SK}_u,{\tt M}_{\,r})$ and $\lambda=H\left(\pi_{u,r}\right)$
    \vspace{1ex}
    \If{$\lambda\leq\epsilon$}
        \State Return $\left({\tt TRUE},\pi_{u,r}\right)$
    \Else 
        \State Return {\tt FALSE}
    \EndIf
\end{algorithmic}
\end{spacing}
\end{algorithm}

\begin{algorithm}[H]
\caption{Procedure for anyone to validate $u$'s claimed committee membership.}
\label{alg:committee-valid}
\begin{spacing}{1.2}
\begin{algorithmic}[1]
    \vspace{1ex}
    \State Compute ${\tt M}_{\,r}$
    \vspace{1ex}
    \If{$V_{vrf}({\tt PK}_u,\pi_{u,r})={\tt FALSE}$}
        \State Return {\tt FALSE}
    \EndIf
    \vspace{1ex}
    \State $\lambda\leftarrow H(\pi_{u,r})$
    \vspace{1ex}
    \If{$\lambda\leq\epsilon$}
        \State Return {\tt TRUE}
    \Else 
        \State Return {\tt FALSE}
    \EndIf
\end{algorithmic}
\end{spacing}
\end{algorithm}

\subsection{Random Beacon}
\label{sec:beacon}

Nodes need to compute common message~${\tt M}_{\,r}$ to determine and validate committee memberships. It is desirable to add certain randomness in the computation such that adversaries only know their committee memberships in a limited number of rounds in future.

To do that, we divide the consensus process into epochs each of which lasts for $L$ rounds where $L$ is a predetermined fixed number. Let $\hat{B}_{u,r}^{\,m}$ be the last block on the canonical chain observed by $u$ in the $m$'th epoch. Node~$u$ can compute a random beacon~$b_u^m$ from $\hat{B}_{u,r}^{\,m}$ as:

\begin{equation}
    b_u^m \leftarrow H({\tt Sig}_{\,l_r}(\pi_{u_1,r}\,\|\,\pi_{u_1,r}\,\|\,\cdots\,\|\,\pi_{u_d,r})).
\end{equation}

Here we define $b_u^0\leftarrow H(B_{\textrm{genesis}})$. Beacon~$b_u^m$ is then used to calculate VRF messages for the next epoch. In particular, we compute message~${\tt M}_{\,r'}$ in round~$r'$ as:

\begin{equation}
    {\tt M}_{\,r'} \leftarrow H(b_u^m\,\|\,r')
\end{equation}

where $mL+1\leq r'\leq m(L+1)$.

Now let us consider the case when the leader who generates $\hat{B}_{u,r}^{\,m}$ is malicious. Since signatures from the committee members are deterministic, the best he can do is to go through every combination of $d$ signatures from all the signatures he has received from committee members and pick the one that maximizes his interest. The number of possible trials is fairly limited and therefore, we significantly limit the leader's influence on the beacon.

% \subsection{Block Reward}
% With the committee mechanism in place, the block reward needs to be shared between the leader and committee members. We propose to give half of the total block reward to the leader and the rest equally distributed to the committee members.

\subsection{Double-Spending Attack}
The main goal of introducing the committee mechanism is to make it more difficult for adversaries to cause inconsistency. Perhaps the most damaging of such attacks is the double-spending attacks~(DSAs)~\cite{Sat08} where adversaries are allowed to take control of a few consecutive consensus rounds such that they can produce two parallel branches to launch a DSA. Here we are going to infer a upper bound for the probability of launching a $k$-block DSA. 

Let $p_\epsilon$ be the probability of a node being selected as a committee member. This probability is directly related to threshold~$\epsilon$ and is equal to every node thanks to VRF. Let us assume that there are $f$ malicious nodes that can behave arbitrarily. To produce two valid, but contradicting blocks in the same round, adversaries must control both the leader and $d$ committee members. The probability of existence of $d$ committee members being malicious can be computed as:

\begin{equation}
    F(p_\epsilon,d,f) = \sum_{i=d}^f \binom{f}{i}\,{p_\epsilon}^i\left(1-p_\epsilon\right)^{f-i}
\end{equation}

Therefore, the probability of adversaries controlling the committee for $k$ consecutive rounds is $F(p_\epsilon,d,f)^k$. Table~\ref{tab:dsa-prob} lists the values of this probability with different inputs. We set $f$ according to the Byzantine Fault Tolerance~(BFT) assumption. It is a security assumption that is considered reasonable and widely used in practice.

Now let us consider the worse-case scenario when a malicious leader is selected to generate the block in the last epoch from which the random beacon for the current epoch is computed. The best he can do is to try all the combinations of $d$ valid signatures he receives from the committee members to search for a combination that will result in $k$ consecutive rounds in which leaders are all malicious in the next epoch. Therefore, we can compute a upper bound for the probability of launching a $k$-block DSA as:

\begin{equation}
    F^*(k,p_\epsilon,d,f) = \binom{c}{d}\cdot\left(\frac{f}{N}\right)^k\cdot F(p_\epsilon,d,f)^k.
\end{equation}

where $c$ is the total number of committee-member signatures the leader receives. Table~\ref{tab:dsa-prob} below provides some examples of the probabilities of launching a DSA. 

\begin{table}[H]
    \centering
    \begin{tabular}{|c|C{2.5cm}|C{2.5cm}|}
        \hline
        $N = 101$, $f=33$ & $k=5$ & $k=10$ \\
        \hline\hline
        $d=5$ & $1.86\times10^{-7}$ & $1.65\times10^{-15}$ \\
        \hline
        $d=10$ & $2.78\times10^{-8}$ & $1.17\times10^{-19}$ \\
        \hline
    \end{tabular}
    \vspace{2ex}
    \caption{Examples of probabilities $F(p_\epsilon,d,f)^k$. Here we compute $p_\epsilon=1.5\cdot d/N$ and $c=\lfloor1.5\cdot d\rfloor$.}
    \label{tab:dsa-prob}
\end{table}

% \Urlmuskip=0mu plus 1mu\relax
\bibliographystyle{unsrt}  
\bibliography{references}

\end{document}