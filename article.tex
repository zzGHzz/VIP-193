\documentclass{article}

\usepackage{arxiv}

\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{url}   % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{lipsum}

\usepackage{longtable}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{setspace}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{multirow}

\title{VIP-193: Committee-Based POA}
\author{
  Ziheng (Peter) Zhou \vspace{1ex}\\
  VeChain Foundation \\
  \texttt{peter.zhou@vechain.com}
  \And
  Zhijie Ren \vspace{1ex} \\
  VeChain Foundation \\
  \texttt{zhijie.ren@vechain.com}
}

\date{\vspace{-5ex}}

\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}\vspace{3pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}\vspace{3pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}\vspace{3pt}}m{#1}}

\usepackage{abstract}
\renewcommand{\abstractname}{}
\renewcommand{\absnamepos}{empty}

\begin{document}
\maketitle

% \begin{abstract}
% \begin{itemize}
%     \item VIP: 193
%     \item Title: Committee-Based POA
%     \item Author: Ziheng Zhou (peter.zhou@vechain.com) and Zhijie Ren (zhijie.ren@vechain.com)
%     \item Category: Core
%     \item Status: Draft
%     \item CreateAt: 2019-11-05
% \end{itemize}
% \end{abstract}

% keywords can be removed
% \keywords{First keyword \and Second keyword \and More}


\section{Overview}
The Proof-of-Authority consensus algorithm~\cite{VWP18}, or POA in short, is efficient of using network bandwidth. It divides time into rounds with a fixed length and assumes that the majority of its (authorized) nodes perform consensus in the same round. In each round, nodes select a leader (the node responsible for generating a new block) based on the round number, block height and their local views of active nodes. Therefore, the procedure can be considered instant, which allows more time for transmitting transaction (TX) data in each consensus round.

POA relies on the staked reputation (by nodes) and economic incentives to keep the system secure. However, it cannot stop malicious leaders causing temporary inconsistency. To improve the security of POA, we propose to introduce a committee to endorse the new block generated in each consensus round. The verifiable random function~(VRF)~\cite{PapEtAl99} is used for nodes to locally decide their committee memberships. With the committee mechanism, a malicious leader would have to collude with the committee to cause inconsistency. However, the property of VRF guarantees that the committee is selected randomly. Therefore, it makes it much more difficult for adversaries to launch such attacks.

We assume that the network is synchronous and the messages are transmitted through gossip communication, i.e., if an honest node sends a message or an honest node receives a message, all other honest nodes will receive same message within at most a delay of $\tau$, which is determined by the network configuration and known in advance.

%Note that besides the network synchrony, we also assume that messages be transmitted through gossip communication. Hence, if an honest node receives a message, all other honest nodes will receive the same message with a bounded delay. 
\section{Specifications}
\subsection{Notations}
\renewcommand{\arraystretch}{2}
\begin{longtable}{p{3cm} p{10cm}}
    Symbol  & Description \\
    \hline\hline
    $N$ & Total number of nodes \\
    \hline
    $u=1,2,\dots,N$ & node index \\
    \hline
    $H(\cdot)$ & Cryptographic hash function \\
    \hline
    ${\tt SIG}_u(\cdot)$ & Signature of $u$ \\
    \hline
    ${\tt PK}_u$ & Public key of $u$ \\
    \hline
    ${\tt SK}_u$ & Private key of $u$ \\
    \hline
    $\rho\left(\cdot\right)$ & Merkle root of the input set\\
    \hline
    $r$ & Consensus round number \\
    \hline
    $l_r=1,2,...,N$ & Leader in round $r$ \\
    \hline
    $s_r$ & Block summary produced by $l_r$ \\
    \hline
    $\tau_r$ & $s_r\,\|\,{\tt Sig}_{\,l_r}(s_r)$ \\
    \hline
    $\epsilon$ & Predefined threshold to determine committee memberships \\
    \hline
    $d$ & Number of endorsements required for forming a valid block \\
    \hline
    $\Sigma_r$ & Pending transaction set prepared by $l_r$ \\
    \hline
    $B_{u,r}^*$ & Last block of the canonical chain recognized by $u$ in round $r$\\ 
    \hline
    $H_{vrf},\Pi_{vrf},V_{vrf}$ & Functions that compute hash, generate proof and verify proof defined in the VRF scheme, respectively \\
    \hline
    ${\tt M}_{\,r}$ & Common VRF message generated for committee selection \\
    \hline
    $\omega$, $\omega^*$ & Branch and trunk \\
    \hline
    $m$, $L$ & Epoch number and the number of consensus rounds in one epoch \\
    \hline
    $b_m$ & Random beacon computed using randomness from the last block of the $m$'th epoch \\
    \hline
\end{longtable}

\subsection{Committee Membership}
\label{sec:committee}
The verifiable random function can be considered as a public-key version of keyed cryptographic hash. The hash of a given message can only be computed by the owner of the private key and can be verified by anyone given the public key~{\tt SK} and message~{\tt M}. The scheme defines the following functions:
\begin{itemize}
    \item $\pi\leftarrow\Pi_{vrf}({\tt SK},{\tt M})$ - function that generates VRF proof;
    \item $\{{\tt TRUE}, {\tt FALSE}\}\leftarrow V_{vrf}({\tt SK},{\tt M},\pi)$ - function that verify VRF proof;
    \item $h\leftarrow H_{vrf}({\tt SK},{\tt M})=H(\pi)$ - function that computes the hash.
\end{itemize}

Node~$u$ determines his committee membership by Algorithm~\ref{alg:committee-gen}. Here ${\tt M}_{\,r}$ is the common VRF message computed in round $r$ and $\epsilon$ a predefined threshold. See Section~\ref{sec:beacon} for details of the computation of ${\tt M}_{\,r}$. Given the VRF proof and the corresponding public key, anyone can verify the membership claimed by $u$ by Algorithm~\ref{alg:endorse-valid} as shown below.

\begin{algorithm}[H]
\caption{Procedure for $u$ to determine his committee membership. }
\label{alg:committee-gen}
\begin{spacing}{1.2}
\begin{algorithmic}[1]
    \vspace{1ex}
    \State Compute ${\tt M}_{\,r}$
    \State Compute $\pi_{u,r} = \Pi_{vrf}({\tt SK}_u,{\tt M}_{\,r})$ and $\lambda=H\left(\pi_{u,r}\right)$
    \vspace{1ex}
    \If{$\lambda\leq\epsilon$}
        \State Return $\left({\tt TRUE},\pi_{u,r}\right)$
    \Else 
        \State Return {\tt FALSE}
    \EndIf
\end{algorithmic}
\end{spacing}
\end{algorithm}

\begin{algorithm}[H]
\caption{Procedure for anyone to validate $u$'s claimed committee membership.}
\label{alg:committee-valid}
\begin{spacing}{1.2}
\begin{algorithmic}[1]
    \vspace{1ex}
    \State Compute ${\tt M}_{\,r}$
    \vspace{1ex}
    \If{$V_{vrf}({\tt PK}_u,\pi_{u,r})={\tt FALSE}$}
        \State Return {\tt FALSE}
    \EndIf
    \vspace{1ex}
    \State $\lambda\leftarrow H(\pi_{u,r})$
    \vspace{1ex}
    \If{$\lambda\leq\epsilon$}
        \State Return {\tt TRUE}
    \Else 
        \State Return {\tt FALSE}
    \EndIf
\end{algorithmic}
\end{spacing}
\end{algorithm}

\subsection{Block Summary}
At the beginning of round~$r$, leader $l_r$ computes the summary of the new block, $s_r$, and broadcast it for the committee members to endorse the block. Algorithms~\ref{alg:bs-gen} and \ref{alg:bs-valid} shows the computation and validation process of $s_r$, respectively. In Algorithm~\ref{alg:bs-valid}, $B_{u,r}^*$ is the last block of the canonical chain locally recognized by $u$ at the beginning of round~$r$. Lines~6-10 dictate that $l_r$'s view on the canonical chain must be consistent with that of $u$.

\begin{algorithm}[H]
\caption{Procedure for $l_r$ to compute and broadcast $s_r$.}
\label{alg:bs-gen}
\begin{spacing}{1.2}
\begin{algorithmic}[1]
    \vspace{1ex}
    \State Prepares $\Sigma_r$ and computes $\rho\left(\Sigma_r\right)$
    \State Get the last block on the canonical chain, $B_{l_r}^*$ and computer $h_0=H({\tt HEADER}(B_{l_r,r}^*))$
    \State $s_r\leftarrow h_0\,\|\,r\,\|\,\rho\left(\Sigma_r\right)$
    \State Broadcast $\left(s_r,{\tt Sig}_{\,l_r}(s_r)\right)$
\end{algorithmic}
\end{spacing}
\end{algorithm}

\begin{algorithm}[H]
\caption{Procedure for $u$ to validate $s_r$.}
\label{alg:bs-valid}
\begin{spacing}{1.2}
\begin{algorithmic}[1]
    \vspace{1ex}
    \State Compute $l_r$
    \If{$s_r$ is not sent from $l_r$}
        \State Return {\tt FALSE}
    \EndIf
    \vspace{1ex}
    \State Verify ${\tt Sig}_{\,l_r}(s_r)$
    \vspace{1ex}
    \State Extract $B_{u,r}^*$ and compute ${\tt HEADER}(B_{u,r}^*)$
    \If{${\tt HEADER}(B_{u,r}^*)\neq{\tt HEADER}(B_{l_r,r}^*)$}
        \State Return {\tt FALSE}
    \EndIf
    \vspace{1ex}
    \State Return {\tt TRUE}
\end{algorithmic}
\end{spacing}
\end{algorithm}

\subsection{Endorsement}

After receiving block summary~$s_r$, if node~$u$ is a committee member, he then executes Algorithm~\ref{alg:endorse-gen} to endorse the block proposed by $l_r$. Here we define $\tau_r=s_r\,\|\,{\tt Sig}_{\,l_r}(s_r)$.

\begin{algorithm}[H]
\caption{Procedure for $u$ to endorse a new block.}
\label{alg:endorse-gen}
\begin{spacing}{1.2}
\begin{algorithmic}[1]
    \vspace{1ex}
    \State Verify $s_r$ by Algorithm~\ref{alg:bs-valid}
    \State Broadcast $\Big(u,s_r,{\tt SIG}_u(\tau_r),\pi_{u,r}\Big)$
\end{algorithmic}
\end{spacing}
\end{algorithm}

Once a node receives an endorsement message from $u$, he first verify $s_r$ by Algorithm~\ref{alg:bs-valid} and then validate $u$'s endorsement by Algorithm~\ref{alg:endorse-valid}.

\begin{algorithm}[H]
\caption{Procedure for validating $u$'s endorsement.}
\label{alg:endorse-valid}
\begin{spacing}{1.2}
\begin{algorithmic}[1]
    \vspace{1ex}
    \State Verify ${\tt SIG}_{u}(\tau_r)$
    \State Verify $u$'s committee membership by Algorithm~\ref{alg:committee-valid}
\end{algorithmic}
\end{spacing}
\end{algorithm}

\subsection{Block}

Algorithm~\ref{alg:block-gen} describes the procedure for leader~$l_r$ to publish a new block in round~$r$.

\begin{algorithm}[H]
\caption{Procedure for $l_r$ to publish a new block.}
\label{alg:block-gen}
\begin{spacing}{1.2}
\begin{algorithmic}[1]
    \vspace{1ex}
    \State Compute and broadcast $s_r$ by Algorithm~\ref{alg:bs-gen}
    \State Broadcast TX set~$\Sigma_r$
    \State Wait for $d$ valid endorsements and arrange the committee members such that $u_1<u_2<\dots<u_d$
    \State $\Gamma_r\leftarrow{\tt SIG}_{u_1}(\tau_r)\,\|\,{\tt SIG}_{u_2}(\tau_r)\,\|\,\dots\,\|\,{\tt SIG}_{u_d}(\tau_r)$
    \State Broadcast $\left(s_r,{\tt Sig}_{\,l_r}(s_r),{\tt Sig}_{\,l_r}(\Gamma_r),
    \left\{u_i,{\tt SIG}_{u_i}(\tau_r),\pi_{u_i,r}\right\}_{i=1}^d\right)$
    \State Construct header body~$\Omega$ and broadcast ${\tt Sig}_{\,l_r}(\Omega)$
\end{algorithmic}
\end{spacing}
\end{algorithm}

A block header body $\Omega$ contains the following elements:
\begin{enumerate}
    \item Hash of the parent header $H({\tt HEADER}(B_{l_r,r}^*))$ 
    \item Round number $r$
    \item TX Merkle tree root $\rho\left(\Sigma_r\right)$
    \item Signature ${\tt Sig}_{\,l_r}(s_r)$
    \item Committee member list $\left(u_1<u_2<\dots<u_d\right)$
    \item Merkle tree root of VRF proofs $\left\{\pi_{u_i,r}\right\}_{i=1}^d$
    \item Merkle tree root of signatures $\left\{{\tt SIG}_{u_i}(\tau_r)\right\}_{i=1}^d$
    \item Signature ${\tt Sig}_{\,l_r}(\Gamma_r)$
    % \item Other necessary header elements such as the state root, receipt root, gas limit and etc.
\end{enumerate}

A block consists of a header $\left\{\Omega,{\tt Sig}_{\,l_r}(\Omega)\right\}$ and TX set~$\Sigma_r$. Algorithm~\ref{alg:block-valid} describes how to validate a block generated in round $r$. To prevent a malicious leader to deliberately delay the transmission of block elements to cause inconsistency, honest nodes would accept a new block only if they validated it in the same round.

\begin{algorithm}[H]
\caption{Procedure for validating a block generated in round $r$.}
\label{alg:block-valid}
\begin{spacing}{1.2}
\begin{algorithmic}[1]
    \vspace{1ex}
    \State Verify $s_r$ by Algorithm~\ref{alg:bs-valid}
    \State Verify $\rho\left(\Sigma_r\right)$
    \For{$i=1,2,\dots,d$}
        \State Verify $u_i$'s endorsement by Algorithm~\ref{alg:endorse-valid}
    \EndFor
    \State Construct $\Gamma_r$ and verify ${\tt Sig}_{\,l_r}(\Gamma_r)$
    \State Construct header body~$\Omega$ and verify ${\tt Sig}_{\,l_r}(\Omega)$
    \State Verify $\Sigma_r$ 
\end{algorithmic}
\end{spacing}
\end{algorithm}

Note that we only list the elements related to the committee mechanism for simplicity. Algorithms~\ref{alg:block-gen} and \ref{alg:block-valid} should be adjusted accordingly to accommodate other elements such as the gas limit, state root, receipt root, etc.

\subsection{Canonical Chain Rule}
In this subsection, we provide the rules for selecting the canonical chain (or the \textit{trunk}) based on the committee mechanism. Let $\omega$ be a branch, i.e., a chain of blocks. Given a block~$B$ on the branch, i.e.,~$B\in\omega$, we define the weight of the chain starting from $B$ till the end of $\omega$,~$W(\omega,B)$, as the size of the set that contains all the leaders and committee members who have their signatures included in at least one block on the chain. Note that a node is only counted once.

Given two branches $\omega_1$ and $\omega_2$, let $B_0$ be the last block shared by $\omega_1$ and $\omega_2$, i.e., $B_0\in\omega_1\cap\,\omega_2$ and $\forall\, B'\in\omega_1\cap\,\omega_2,\, B'\preceq B_0$. Let $N(\omega,B)$ be the operator that finds the next block of $B$ on branch~$\omega$. We choose the canonical chain~$\omega^*$ from two branches~$\omega_1$ and $\omega_2$ by Algorithm~\ref{alg:canonical-chain} as shown below:

\begin{algorithm}[H]
\caption{Rules for choosing canonical chain~$\omega^*$ from branches~$\omega_1$ and $\omega_2$.}
\label{alg:canonical-chain}
\begin{spacing}{1.2}
\begin{algorithmic}[1]
    \vspace{1ex}
    \State $B_1\leftarrow N(\omega_1,B_0)$
    \State $B_2\leftarrow N(\omega_2,B_0)$
    \vspace{1ex}
    \While{$W(\omega_1,B_1)=W(\omega_2,B_2)$ \textbf{and} $N(\omega_1,B_1)\neq{\tt nil}$ \textbf{and} $N(\omega_2,B_2)\neq{\tt nil}$}
        \State $B_1\leftarrow N(\omega_1,B_1)$
        \State $B_2\leftarrow N(\omega_2,B_2)$
    \EndWhile
    \vspace{1ex}
    \If{$W(\omega_1,B_1)>W(\omega_2,B_2)$}
        \State $\omega^*\leftarrow\omega_1$
    \ElsIf{$W(\omega_1,B_1)<W(\omega_2,B_2)$}
        \State $\omega^*\leftarrow\omega_2$
    \Else
        \If{$B_1$ is published later than $B_2$}
            \State $\omega^*\leftarrow\omega_1$
        \Else
            \State $\omega^*\leftarrow\omega_2$
        \EndIf
    \EndIf
\end{algorithmic}
\end{spacing}
\end{algorithm}

\subsection{Random Beacon}
\label{sec:beacon}

In Algorithms~\ref{alg:committee-gen} and \ref{alg:committee-valid}, nodes need to compute common message~${\tt M}_{\,r}$ to determine and validate committee memberships. It is desirable to add certain randomness in the computation such that adversaries only know their committee memberships in a limited number of rounds in future.

To do that, we divide the consensus process into epochs each of which lasts for $L$ rounds where $L$ is a predetermined fixed number. Let $\hat{B}_{u,r}^{\,m}$ be the last block on the canonical chain observed by $u$ in the $m$'th epoch. Node~$u$ can compute a random beacon~$b_u^m$ from $\hat{B}_{u,r}^{\,m}$ as:

\begin{equation}
    b_u^m \leftarrow H({\tt Sig}_{\,l_r}(\pi_{u_1,r}\,\|\,\pi_{u_1,r}\,\|\,\cdots\,\|\,\pi_{u_d,r})).
\end{equation}

Here we define $b_u^0\leftarrow H(B_{\textrm{genesis}})$. Beacon~$b_u^m$ is then used to calculate VRF messages for the next epoch. In particular, we compute message~${\tt M}_{\,r'}$ in round~$r'$ as:

\begin{equation}
    {\tt M}_{\,r'} \leftarrow H(b_u^m\,\|\,r')
\end{equation}

where $mL+1\leq r'\leq m(L+1)$.

Now let us consider the case when the leader who generates $\hat{B}_{u,r}^{\,m}$ is malicious. Since signatures from the committee members are deterministic, the best he can do is to go through every combination of $d$ signatures from all the signatures he has received from committee members and pick the one that maximizes his interest. The number of possible trials is fairly limited and therefore, we significantly limit the leader's influence on the beacon.

\subsection{Optimizing Bandwidth Usage}
A more efficient usage of network bandwidth often results in a higher system throughput. By more efficient, we mean that there is more time to transmit TXs in each round of consensus. To do that, we detach the endorsing process from the block validation process. In particular, committee members can endorse a new block without receiving and validating the complete set of TXs included in the block. See Algorithms~\ref{alg:bs-gen} and \ref{alg:bs-valid} for details. In this way, we would be able to significantly shorten the whole endorsing process and potentially allow more bandwidth used for TX transmission. 

Note that TXs will be checked by nodes when validating any newly received block and any invalid TX will cause the block to be discarded even though all the endorsements are valid. 

\subsection{Block Reward}
With the committee mechanism in place, the block reward needs to be shared between the leader and committee members. We propose to give half of the total block reward to the leader and the rest equally distributed to the committee members.

\subsection{Double-Spending Attack}
The main goal of introducing the committee mechanism is to make it more difficult for adversaries to cause inconsistency. Perhaps the most damaging of such attacks is the double-spending attacks~(DSAs)~\cite{Sat08} where adversaries are allowed to take control of a few consecutive consensus rounds such that they can produce two parallel branches to launch a DSA. Here we are going to infer a upper bound for the probability of launching a $k$-block DSA. 

Let $p_\epsilon$ be the probability of a node being selected as a committee member. This probability is directly related to threshold~$\epsilon$ and is equal to every node thanks to VRF. Let us assume that there are $f$ malicious nodes that can behave arbitrarily. To produce two valid, but contradicting blocks in the same round, adversaries must control both the leader and $d$ committee members. The probability of existence of $d$ committee members being malicious can be computed as:

\begin{equation}
    F(p_\epsilon,d,f) = \sum_{i=d}^f \binom{f}{i}\,{p_\epsilon}^i\left(1-p_\epsilon\right)^{f-i}
\end{equation}

Therefore, the probability of adversaries controlling the committee for $k$ consecutive rounds is $F(p_\epsilon,d,f)^k$. Table~\ref{tab:dsa-prob} lists the values of this probability with different inputs. We set $f$ according to the Byzantine Fault Tolerance~(BFT) assumption. It is a security assumption that is considered reasonable and widely used in practice.

Now let us consider the worse-case scenario when a malicious leader is selected to generate the block in the last epoch from which the random beacon for the current epoch is computed. The best he can do is to try all the combinations of $d$ valid signatures he receives from the committee members to search for a combination that will result in $k$ consecutive rounds in which leaders are all malicious in the next epoch. Therefore, we can compute a upper bound for the probability of launching a $k$-block DSA as:

\begin{equation}
    F^*(k,p_\epsilon,d,f) = \binom{c}{d}\cdot\left(\frac{f}{N}\right)^k\cdot F(p_\epsilon,d,f)^k.
\end{equation}

where $c$ is the total number of committee-member signatures the leader receives. Table~\ref{tab:dsa-prob} below provides some examples of the probabilities of launching a DSA. 

\begin{table}[H]
    \centering
    \begin{tabular}{|c|C{2.5cm}|C{2.5cm}|}
        \hline
        $N = 101$, $f=33$ & $k=5$ & $k=10$ \\
        \hline\hline
        $d=5$ & $1.86\times10^{-7}$ & $1.65\times10^{-15}$ \\
        \hline
        $d=10$ & $2.78\times10^{-8}$ & $1.17\times10^{-19}$ \\
        \hline
    \end{tabular}
    \vspace{2ex}
    \caption{Examples of probabilities $F(p_\epsilon,d,f)^k$. Here we compute $p_\epsilon=1.5\cdot d/N$ and $c=\lfloor1.5\cdot d\rfloor$.}
    \label{tab:dsa-prob}
\end{table}

% \Urlmuskip=0mu plus 1mu\relax
\bibliographystyle{unsrt}  
\bibliography{references}

\end{document}